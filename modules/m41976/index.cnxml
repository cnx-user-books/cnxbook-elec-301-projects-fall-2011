<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Background and Approach</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m41976</md:content-id>
  <md:title>Background and Approach</md:title>
  <md:abstract>This module describes how we created our blurry image and applied the FTVd algorithm.</md:abstract>
  <md:uuid>ad1b8d27-6fd8-4c87-8202-6204a95ee55e</md:uuid>
</metadata>

<content>
    <para id="id1171576143144">Background</para>
    <para id="id1171573419476">What are the causes of the image distortion? Well using the given model for our blurry observation there are two causes: K and omega. </para>
    <para id="id1171578942469">K is a blurring kernel. It is a matrix convolved with our original image <emphasis effect="italics">u </emphasis>that performs a linear operation to represent the effects of a particular kind of blur<emphasis effect="italics">. </emphasis>Omega is a term used to represent the additive forms of noise introduced by our camera and the environment into our imperfect observation. </para>
    <para id="id1171576577705">To model and recover our image, we applied an algorithm know as the Fast Total Variation Deconvolution. </para>
    <para id="id1171572871744">Fast Total Variation Deconvolution takes advantage of our problem structure and assumes several facts about the information in our image. Because of the additive noise in all of our observations, we cannot directly recover our desired image from the blurry observation by performing the inverse of operation, deconvolve our original image with the blurring kernel. Instead, we first try to minimize the noise to approximate an ideal blurring. Then we can invert the problem to find <emphasis effect="italics">u</emphasis>. </para>
    <para id="id1171573359357">To do this we model our problem using the following equation:</para>
    <para id="id1171573368183"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:munder><m:mtext>min</m:mtext><m:mstyle fontsize="8pt"><m:mrow><m:mi>u</m:mi></m:mrow></m:mstyle></m:munder><m:mrow><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">=</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:msup><m:mi>n</m:mi><m:mstyle fontsize="6pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup></m:mrow></m:mstyle></m:munderover><m:mrow><m:mo stretchy="false">∥</m:mo><m:mrow><m:msub><m:mi>D</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:msub><m:mi>u</m:mi></m:mrow><m:mo stretchy="false">∥</m:mo></m:mrow></m:mrow><m:mo stretchy="false">+</m:mo><m:mfrac><m:mi>m</m:mi><m:mn>2</m:mn></m:mfrac></m:mrow><m:msubsup><m:mrow><m:mo stretchy="false">∥</m:mo><m:mrow><m:mrow><m:mi>K</m:mi><m:mo stretchy="false">∗</m:mo><m:mi>u</m:mi></m:mrow><m:mo stretchy="false">−</m:mo><m:mi>f</m:mi></m:mrow><m:mo stretchy="false">∥</m:mo></m:mrow><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ {"min"}  cSub { size 8{u} }  Sum cSub { size 8{i=1} }  cSup { size 8{n rSup { size 6{2} } } }  { ldline D rSub { size 8{i} } u rdline } + {  {m}  over  {2} }  ldline K*u-f rdline  rSub {2}  rSup {2} } {}</m:annotation></m:semantics></m:math> [5]</para>
    <para id="id1171576146610">In the equation above, we have two terms: the first is our total variation norm, which is a discretized gradient measured across our entire image, the second is the data fidelity term. The data fidelity term attempts to make the difference between our blurry observation and an ideally blurred image very small. If the difference were zero, we could very easily perform the deconvolution to recover <emphasis effect="italics">u</emphasis>. So, the minimization step will take us as close as possible to a problem with a closed form solution. This model supposes a few facts about our problem. Primarily, it assumes that the majority of scenes in the real world will have flat, uniform surfaces. This means that our image should have very few nonzero gradients and the additive noise will introduce many random peaks and thus non-zero gradients to be minimized. </para>
    <para id="id1171572858804">The full form of the Total Variation Regularization transforms our first model into the following:</para>
    <para id="id1171575775812"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:munder><m:mtext>min</m:mtext><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>w</m:mi><m:mi>,</m:mi><m:mi>u</m:mi></m:mrow></m:mrow></m:mstyle></m:munder><m:mrow><m:mrow><m:munder><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:munder><m:msub><m:mrow><m:mo stretchy="false">∥</m:mo><m:msub><m:mi>w</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">∥</m:mo></m:mrow><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:mo stretchy="false">+</m:mo><m:mfrac><m:mi>β</m:mi><m:mn>2</m:mn></m:mfrac></m:mrow><m:mrow><m:munder><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:munder><m:mrow><m:mrow><m:msubsup><m:mrow><m:mo stretchy="false">∥</m:mo><m:mrow><m:mrow><m:msub><m:mi>w</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">−</m:mo><m:msub><m:mi>D</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>i</m:mi></m:mrow></m:mstyle></m:msub></m:mrow><m:mi>u</m:mi></m:mrow><m:mo stretchy="false">∥</m:mo></m:mrow><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msubsup><m:mo stretchy="false">+</m:mo><m:mfrac><m:mi>m</m:mi><m:mn>2</m:mn></m:mfrac></m:mrow><m:msubsup><m:mrow><m:mo stretchy="false">∥</m:mo><m:mrow><m:mrow><m:mi>K</m:mi><m:mo stretchy="false">∗</m:mo><m:mi>u</m:mi></m:mrow><m:mo stretchy="false">−</m:mo><m:mi>f</m:mi></m:mrow><m:mo stretchy="false">∥</m:mo></m:mrow><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msubsup></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ {"min"}  cSub { size 8{w,u} }  Sum cSub { size 8{i} }  { ldline w rSub { size 8{i} }  rdline  rSub { size 8{2} } } + {  {β}  over  {2} }  Sum cSub { size 8{i} }  { ldline w rSub { size 8{i} } -D rSub { size 8{i} } u rdline  rSub { size 8{2} }  rSup { size 8{2} } + {  {m}  over  {2} }  ldline K*u-f rdline  rSub { size 8{2} }  rSup { size 8{2} } } } {}</m:annotation></m:semantics></m:math> [5]</para>
    <para id="id1171573131653">This equation adds another term to our model. Here we try to minimize the difference between the non-zero gradients and some term <emphasis effect="bold">w</emphasis>, while simultaneously trying to make <emphasis effect="bold">w</emphasis> as small as possible. The beta parameter in the second term helps to establish convergence, when beta is very large. For our purposes, we have used the parameters for convergence given by the FTVd reference, which has chosen optimal value for beta. We can group these terms together as the regularizing term, which constrains our model so that we have a well conditioned noisy observation.</para>
    <para id="id1171572222250"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:munder><m:mtext>min</m:mtext><m:mstyle fontsize="8pt"><m:mrow><m:mi>u</m:mi></m:mrow></m:mstyle></m:munder><m:mi>J</m:mi><m:mo stretchy="false">(</m:mo><m:mi>u</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:msub><m:mi>F</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>reg</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>u</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">+</m:mo><m:mfrac><m:mi>m</m:mi><m:mn>2</m:mn></m:mfrac></m:mrow><m:msup><m:mrow><m:mo stretchy="false">∥</m:mo><m:mrow><m:mrow><m:mi>K</m:mi><m:mo stretchy="false">∗</m:mo><m:mi>u</m:mi></m:mrow><m:mo stretchy="false">−</m:mo><m:mi>f</m:mi></m:mrow><m:mo stretchy="false">∥</m:mo></m:mrow><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ {"min"}  cSub { size 8{u} } J \( u \) =F rSub { size 8{ ital "reg"} }  \( u \) + {  {m}  over  {2} }  ldline K*u-f rdline  rSup { size 8{2} } } {}</m:annotation></m:semantics></m:math> [5]</para>
    <para id="id1171572830846">There are many other possible forms for constrained minimization. Different constraints will result in different ability for our model to converge. The FTVd algorithm performs this minimization using 2FFT’s and one inverse FFT, giving a complexity of N log (N). In particular, we note that the FTVd will converge quickly with relatively little iteration, but it is also important to note that our problem sacrifices some clarity on textured surfaces. This algorithm is ideal for quick noise removal. </para>
    <para id="id1171573159683">It is also important to say that this algorithm cannot function without passing in the blurring kernel. In many real world situations, such as the random motion of a handshake, it is impossible to know the blurring kernel to one hundred percent accuracy. In this case, it would be necessary to use a blind deconvolution. The process of blind deconvolution will estimate the point spread function of the blur kernel. However, in general it is always necessary to calculate the point spread function of the blur kernel. Any signal received will be a convolution of input signal with the impulse response of the receiving system. So, to fully recover the input signal, we will need to the impulse response of our camera and any other functions that have acted on our input, namely the blur and the noise.
</para>
    <para id="eip-593">The FTVd code has been attached to this module. I has been provided open source with much thanks to Dr. Yin and his group [5].</para><para id="id1171572801070">Approach</para>
    <para id="id1171575200029">In our project, we model four different type of real world blur, each under two possible types of noise. We break these types of blur up in three different categories and model then each with their respective blurring kernels: handshake motion, motion of the observed object, and out of focus blur. </para>
    <para id="id1171573151061">For handshake blur, we used data collected experimentally by our Microsoft reference to develop a kernel [1]. We chose a kernel that represents a small, defined shake at the point of observation and applied it equally to the whole of the image. This data is very much similar to the linear motion function, but represents a two dimensional curve. We could have chosen to model this situation by piecing together some linear motion curves, but this more accurately represents the random motion that is possible when holding the image-capturing device. Inherently, the motion of a handshake will be unique to each observation, but in this case we have chose a specific motion blur to simplify our recovery process. </para>
    <para id="id1171573111668">Here is our handshake kernel, represented as a black and white image:</para>
    <para id="id1171578597030"><figure id="id1171573194962"><media id="id1171573194962_media" alt=""><image mime-type="image/png" src="../../media/Picture 3-3fbf.png" id="id1171573194962__onlineimage" height="95" width="72"/></media></figure> [3]</para>
    <para id="id1171572841208">For the linear motion of an observed object, we have also chosen a determined value for the motion that will simplify our calculations. We assume that the object observed is large compared to the size of our whole observation, such that we can blur the whole image uniformly. To develop this kernel we use the matlab function fspecial (‘motion’, amount, theta) function, which will develop a matrix of the specified distance at a specific angle [2].</para>
    <para id="id1171577751109">Here is the linear motion kernel as a black and white image: </para>
    <figure id="id1171572816798">
      <media id="id1171572816798_media" alt="">
        <image mime-type="image/jpg" src="../../media/Picture 4.jpg" id="id1171572816798__onlineimage" height="172" width="97"/>
      </media>
    </figure>
    <para id="id1171572830912">To create a kernel representing out of focus blur, we used a two-dimensional disc and applied this disc to two different situations. The first represents a situation in which the picture was completely out of focus. This could correspond to the picture focused somewhere very far in the distance or infinitesimally close the camera. This results in a totally blurred image. </para>
    <para id="id1171579163462">The next approach approximates a focal point about 10 feet behind Willy’s statue. This means that the foreground is within focus and the background out of focus. To create this image, we had to blur our image in two steps. We found that in general there is no real distance information observable in the received signal. So, we had to investigate the boundary conditions of the image to determine which areas could be considered the foreground and the background. Then our kernel could be applied only to the background of the image. We applied the FTVd algorithm to the whole image uniformly to recover the image. </para>
    <para id="id1171572462713">This is our 2D disc representing an out of focus lens: </para>
    <figure id="id1171575767129">
      <media id="id1171575767129_media" alt="">
        <image mime-type="image/jpg" src="../../media/Picture 5.jpg" id="id1171575767129__onlineimage" height="97" width="97"/>
      </media>
    </figure>
    <para id="id1171576139325">We applied each of these blur kernels under two different noise applications. </para>
    <para id="id1171580409268">The first is Gaussian white noise caused by thermal Johnson-Nyquist noise or shot noise in the operation of transistors in our camera circuitry. To create this kernel we followed the model in the FTVd package, and did not used the predefined noise function. Instead, we created a matrix of random numbers drawn from a Gaussian distribution and added that to the convolution of <emphasis effect="italics">K</emphasis> and <emphasis effect="italics">u</emphasis>. </para>
    <para id="id1171573386121">Next, we applied our blur kernels under L1 noise. L1 noise can be caused by random failures in sensor pixels. This can be mathematically characterized by the presence or absence of Dirac delta functions. Due to the visual nature of corruption caused, L1 noise is often referred to as ‘Salt and Pepper’ noise. We were able to add this L1 noise to our image using the matlab function imnoise. </para>
    <para id="id1171575917079">The following image shows our handshake kernel applied with L2 additive noise PSNR=24.27 dB :</para>
    <para id="id1171576574989">
      <figure id="id1171576166371">
        <media id="id1171576166371_media" alt="">
          <image mime-type="image/jpg" src="../../media/Picture 1-c8ff.jpg" id="id1171576166371__onlineimage" height="600" width="600"/>
        </media>
      </figure>
    </para>
    <para id="id1171575776098">The next image shows our foreground/background distinction in the presence of L1 noise PSNR=14.94 dB:</para>
    <para id="id1171573180413">
      <figure id="id1171573196902">
        <media id="id1171573196902_media" alt="">
          <image mime-type="image/jpg" src="../../media/Picture 2-925b.jpg" id="id1171573196902__onlineimage" height="557" width="558"/>
        </media>
      </figure>
    </para>
  </content>
</document>